<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Secure Gmail Sender</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="site-header">
    <div class="container">
      <h1>Secure Gmail Sender</h1>
      <p class="tagline">A simple, secure tool that helps you send Gmail programmatically using OAuth 2.0.</p>
    </div>
  </header>

  <main class="container">
    <section>
      <h2>About</h2>
      <p>
        Secure Gmail Sender is an application that uses Google OAuth 2.0 for secure access to Gmail accounts. The app never stores user passwords – only the OAuth tokens required to send email on behalf of consenting users. Tokens are stored securely and are refreshed using Google's recommended flows.
      </p>
    </section>

    <section>
      <h2>Why OAuth 2.0 is More Secure</h2>
      <p>Unlike traditional password-based authentication, OAuth 2.0 provides enhanced security for both you and your data:</p>
      <ul>
        <li><strong>No Password Sharing:</strong> You never share your Gmail password with our app. Authentication happens directly through Google's secure servers.</li>
        <li><strong>Limited Access:</strong> We only request permission to send emails – we cannot read, delete, or modify your existing messages.</li>
        <li><strong>Revocable Access:</strong> You can revoke our app's access anytime through your Google Account settings without changing your password.</li>
        <li><strong>Token-Based Security:</strong> Access tokens expire automatically, and refresh tokens are encrypted in our database for maximum protection.</li>
        <li><strong>Google-Verified:</strong> Our application goes through Google's verification process to ensure it meets their security and privacy standards.</li>
      </ul>
    </section>

    <section>
      <h2>How it works</h2>
      <ol>
        <li><strong>Authorize Once:</strong> Click the authorization button and log in through Google's secure consent screen.</li>
        <li><strong>Grant Permissions:</strong> Approve only the "send email" permission – nothing more.</li>
        <li><strong>Automatic Token Management:</strong> Our app receives secure tokens and handles all refreshing automatically.</li>
        <li><strong>Send Emails Safely:</strong> Use our API or interface to send emails programmatically without exposing your credentials.</li>
      </ol>
    </section>

    <section>
      <h2>Benefits for Users</h2>
      <ul>
        <li><strong>Complete Control:</strong> Maintain full control over your Gmail account with the ability to revoke access instantly.</li>
        <li><strong>Privacy First:</strong> We never read your emails or access your inbox – only send permission is requested.</li>
        <li><strong>Audit Trail:</strong> All sent emails appear in your Gmail "Sent" folder, maintaining full transparency.</li>
        <li><strong>Developer Friendly:</strong> Simple API integration for automating email workflows without security compromises.</li>
        <li><strong>No Credential Storage:</strong> Your password is never stored on our servers, eliminating a major security risk.</li>
        <li><strong>Enterprise Ready:</strong> Suitable for business use with compliance-friendly OAuth 2.0 authentication.</li>
      </ul>
    </section>

    <section>
      <h2>Security & Data Handling</h2>
      <ul>
        <li><strong>Minimal Permissions:</strong> We request only the Gmail send scope (gmail.send) – the absolute minimum required.</li>
        <li><strong>Encrypted Storage:</strong> All OAuth refresh tokens are encrypted at rest using industry-standard AES-256 encryption.</li>
        <li><strong>HTTPS Only:</strong> All communication between your browser and our servers uses TLS/SSL encryption.</li>
        <li><strong>Regular Security Audits:</strong> Our infrastructure undergoes periodic security reviews and vulnerability assessments.</li>
        <li><strong>Zero-Knowledge Architecture:</strong> We never log or store plain-text tokens, passwords, or email content.</li>
        <li><strong>Compliance Ready:</strong> Built following GDPR, SOC 2, and industry best practices for data protection.</li>
      </ul>
    </section>

    <section>
      <h2>Transparency & Trust</h2>
      <p>
        We believe in complete transparency. Our OAuth implementation follows Google's official guidelines and best practices. You can review our privacy policy and terms of service to understand exactly how we handle your data. If you have any security concerns or questions, our team is always available to address them.
      </p>
    </section>

    <section class="links">
      <a href="privacy.html" class="btn">Privacy Policy</a>
      <a href="terms.html" class="btn ghost">Terms of Service</a>
    </section>

    <footer class="legal">
      <p>Contact: <a href="mailto:makaimurphy007@gmail.com">makaimurphy007@gmail.com</a></p>
      <p>&copy; <span id="year"></span> Secure Gmail Sender. All rights reserved.</p>
      <p>Built with OAuth 2.0 for maximum security and user protection.</p>
    </footer>
  </main>

<script>
    document.getElementById('year').textContent = new Date().getFullYear();
    
    // Advanced Holographic Particle System
    function createHolographicParticleTrail(e, targetUrl) {
      e.preventDefault();
      const startX = e.clientX;
      const startY = e.clientY;
      const particleCount = 60;
      const particles = [];
      const canvas = document.createElement('canvas');
      
      // Setup full-screen canvas
      canvas.style.position = 'fixed';
      canvas.style.top = '0';
      canvas.style.left = '0';
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      canvas.style.pointerEvents = 'none';
      canvas.style.zIndex = '99999';
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      document.body.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      
      // Initial shockwave pulse
      createShockwave(startX, startY);
      
      // Create hexagonal grid pattern at click point
      createHexGrid(startX, startY);
      
      // Electromagnetic field lines
      createFieldLines(startX, startY);
      
      // Generate particle system
      for (let i = 0; i < particleCount; i++) {
        const angle = (Math.PI * 2 * i) / particleCount;
        const velocity = 2 + Math.random() * 3;
        const size = 3 + Math.random() * 6;
        const isGreen = Math.random() > 0.3;
        
        particles.push({
          x: startX,
          y: startY,
          vx: Math.cos(angle) * velocity * 0.3,
          vy: Math.sin(angle) * velocity * 0.3,
          targetX: window.innerWidth / 2 + (Math.random() - 0.5) * 150,
          targetY: 50 + Math.random() * 50,
          size: size,
          alpha: 1,
          color: isGreen ? '#76b900' : '#1a1a1a',
          glow: isGreen,
          trail: [],
          life: 1,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.3
        });
      }
      
      // Animation loop with physics
      let frame = 0;
      const animate = () => {
        frame++;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw connecting energy beams between nearby particles
        ctx.strokeStyle = 'rgba(118, 185, 0, 0.15)';
        ctx.lineWidth = 1;
        for (let i = 0; i < particles.length; i++) {
          for (let j = i + 1; j < particles.length; j++) {
            const dx = particles[i].x - particles[j].x;
            const dy = particles[i].y - particles[j].y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 100 && frame < 60) {
              ctx.beginPath();
              ctx.moveTo(particles[i].x, particles[i].y);
              ctx.lineTo(particles[j].x, particles[j].y);
              ctx.stroke();
            }
          }
        }
        
        let allReached = true;
        particles.forEach((p, idx) => {
          // Physics-based movement with attraction to target
          const dx = p.targetX - p.x;
          const dy = p.targetY - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 5) {
            allReached = false;
            const force = 0.05;
            p.vx += (dx / dist) * force;
            p.vy += (dy / dist) * force;
            
            // Apply drag
            p.vx *= 0.98;
            p.vy *= 0.98;
          } else {
            p.vx *= 0.8;
            p.vy *= 0.8;
            p.life *= 0.95;
          }
          
          p.x += p.vx;
          p.y += p.vy;
          p.rotation += p.rotationSpeed;
          
          // Store trail
          p.trail.push({ x: p.x, y: p.y, alpha: p.alpha });
          if (p.trail.length > 20) p.trail.shift();
          
          // Draw electromagnetic trail
          ctx.strokeStyle = p.glow ? 'rgba(118, 185, 0, 0.3)' : 'rgba(26, 26, 26, 0.2)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          p.trail.forEach((pos, i) => {
            if (i === 0) ctx.moveTo(pos.x, pos.y);
            else ctx.lineTo(pos.x, pos.y);
          });
          ctx.stroke();
          
          // Draw particle core with glow
          if (p.glow) {
            const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 3);
            gradient.addColorStop(0, 'rgba(118, 185, 0, ' + p.alpha + ')');
            gradient.addColorStop(0.3, 'rgba(118, 185, 0, ' + (p.alpha * 0.5) + ')');
            gradient.addColorStop(1, 'rgba(118, 185, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(p.x - p.size * 3, p.y - p.size * 3, p.size * 6, p.size * 6);
          }
          
          // Draw particle with rotation
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation);
          ctx.fillStyle = p.color;
          ctx.shadowBlur = p.glow ? 15 : 5;
          ctx.shadowColor = p.glow ? '#76b900' : '#000';
          ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
          ctx.restore();
          
          p.alpha = Math.max(0, p.life);
        });
        
        // Continue animation
        if (frame < 90) {
          requestAnimationFrame(animate);
        } else {
          // Epic convergence explosion
          createConvergenceExplosion(window.innerWidth / 2, 50);
          setTimeout(() => {
            canvas.remove();
            window.location.href = targetUrl;
          }, 800);
        }
      };
      
      animate();
    }
    
    // Initial shockwave effect
    function createShockwave(x, y) {
      const wave = document.createElement('div');
      wave.style.position = 'fixed';
      wave.style.left = x + 'px';
      wave.style.top = y + 'px';
      wave.style.width = '10px';
      wave.style.height = '10px';
      wave.style.border = '2px solid #76b900';
      wave.style.borderRadius = '50%';
      wave.style.transform = 'translate(-50%, -50%)';
      wave.style.pointerEvents = 'none';
      wave.style.zIndex = '99998';
      wave.style.boxShadow = '0 0 30px rgba(118, 185, 0, 0.8), inset 0 0 30px rgba(118, 185, 0, 0.5)';
      document.body.appendChild(wave);
      
      setTimeout(() => {
        wave.style.transition = 'all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
        wave.style.width = '400px';
        wave.style.height = '400px';
        wave.style.opacity = '0';
        wave.style.borderWidth = '1px';
      }, 10);
      
      setTimeout(() => wave.remove(), 700);
    }
    
    // Hexagonal grid pattern
    function createHexGrid(x, y) {
      for (let i = 0; i < 12; i++) {
        const hex = document.createElement('div');
        hex.style.position = 'fixed';
        hex.style.left = x + 'px';
        hex.style.top = y + 'px';
        hex.style.width = '40px';
        hex.style.height = '40px';
        hex.style.border = '1px solid rgba(118, 185, 0, 0.4)';
        hex.style.transform = `translate(-50%, -50%) rotate(${i * 30}deg)`;
        hex.style.clipPath = 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)';
        hex.style.pointerEvents = 'none';
        hex.style.zIndex = '99997';
        document.body.appendChild(hex);
        
        setTimeout(() => {
          hex.style.transition = 'all 0.8s ease-out';
          hex.style.opacity = '0';
          hex.style.transform = `translate(-50%, -50%) rotate(${i * 30 + 180}deg) scale(3)`;
        }, i * 30);
        
        setTimeout(() => hex.remove(), 1000);
      }
    }
    
    // Electromagnetic field lines
    function createFieldLines(x, y) {
      for (let i = 0; i < 8; i++) {
        const line = document.createElement('div');
        line.style.position = 'fixed';
        line.style.left = x + 'px';
        line.style.top = y + 'px';
        line.style.width = '2px';
        line.style.height = '100px';
        line.style.background = 'linear-gradient(180deg, rgba(118, 185, 0, 0.6), transparent)';
        line.style.transformOrigin = 'top center';
        line.style.transform = `translate(-50%, -50%) rotate(${i * 45}deg)`;
        line.style.pointerEvents = 'none';
        line.style.zIndex = '99996';
        line.style.filter = 'blur(1px)';
        document.body.appendChild(line);
        
        setTimeout(() => {
          line.style.transition = 'all 0.5s ease-out';
          line.style.opacity = '0';
          line.style.height = '200px';
        }, i * 20);
        
        setTimeout(() => line.remove(), 700);
      }
    }
    
    // Epic convergence explosion
    function createConvergenceExplosion(x, y) {
      // Central flash
      const flash = document.createElement('div');
      flash.style.position = 'fixed';
      flash.style.left = x + 'px';
      flash.style.top = y + 'px';
      flash.style.width = '20px';
      flash.style.height = '20px';
      flash.style.borderRadius = '50%';
      flash.style.background = 'radial-gradient(circle, #ffffff, #76b900, transparent)';
      flash.style.transform = 'translate(-50%, -50%)';
      flash.style.pointerEvents = 'none';
      flash.style.zIndex = '100000';
      flash.style.boxShadow = '0 0 100px rgba(118, 185, 0, 1)';
      document.body.appendChild(flash);
      
      setTimeout(() => {
        flash.style.transition = 'all 0.6s ease-out';
        flash.style.width = '600px';
        flash.style.height = '600px';
        flash.style.opacity = '0';
      }, 10);
      
      // Shockwave rings
      for (let i = 0; i < 3; i++) {
        setTimeout(() => {
          const ring = document.createElement('div');
          ring.style.position = 'fixed';
          ring.style.left = x + 'px';
          ring.style.top = y + 'px';
          ring.style.width = '50px';
          ring.style.height = '50px';
          ring.style.border = '3px solid #76b900';
          ring.style.borderRadius = '50%';
          ring.style.transform = 'translate(-50%, -50%)';
          ring.style.pointerEvents = 'none';
          ring.style.zIndex = '99999';
          ring.style.boxShadow = '0 0 40px rgba(118, 185, 0, 0.8)';
          document.body.appendChild(ring);
          
          setTimeout(() => {
            ring.style.transition = 'all 0.8s ease-out';
            ring.style.width = '800px';
            ring.style.height = '800px';
            ring.style.opacity = '0';
            ring.style.borderWidth = '1px';
          }, 10);
          
          setTimeout(() => ring.remove(), 900);
        }, i * 100);
      }
      
      // Debris particles
      for (let i = 0; i < 30; i++) {
        const debris = document.createElement('div');
        const angle = (Math.PI * 2 * i) / 30;
        const distance = 150 + Math.random() * 100;
        debris.style.position = 'fixed';
        debris.style.left = x + 'px';
        debris.style.top = y + 'px';
        debris.style.width = (2 + Math.random() * 4) + 'px';
        debris.style.height = debris.style.width;
        debris.style.borderRadius = '50%';
        debris.style.background = Math.random() > 0.5 ? '#76b900' : '#1a1a1a';
        debris.style.transform = 'translate(-50%, -50%)';
        debris.style.pointerEvents = 'none';
        debris.style.zIndex = '99998';
        debris.style.boxShadow = '0 0 10px rgba(118, 185, 0, 0.6)';
        document.body.appendChild(debris);
        
        setTimeout(() => {
          debris.style.transition = 'all 1s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
          debris.style.left = (x + Math.cos(angle) * distance) + 'px';
          debris.style.top = (y + Math.sin(angle) * distance) + 'px';
          debris.style.opacity = '0';
        }, 10);
        
        setTimeout(() => debris.remove(), 1100);
      }
      
      setTimeout(() => flash.remove(), 700);
    }
    
    // Attach to all navigation buttons
    document.querySelectorAll('.btn').forEach(btn => {
      const href = btn.getAttribute('href');
      if (href && (href.includes('.html') || href.includes('/'))) {
        btn.addEventListener('click', (e) => createHolographicParticleTrail(e, href));
      }
    });
  </script>
</body>
</html>



